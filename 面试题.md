# 反射

给了我们在运行时分析和执行类方法的能力。
通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

## 双亲委派

首先知道类加载器有三层：系统类加载器、扩展类加载器、引导类加载器（加载Java核心类如String Object，**引导类加载器无法直接获取**），其中系统类加载器是最常用的加载器，负责加载我们写的类。

类加载器加载类时，先看系统类加载器，类是否已经被加载到内存中，如果还没有，就看双亲：扩展类加载器和引导类加载器。如果都没有，就检查装载范围，看是否由扩展类加载器或引导类加载器加载，如果都不是，最后再由系统类加载器来加载这个类。

双亲委派机制就是为了防止核心类库被篡改。

通过`this.getClass().getClassLoader()`知道这个类由哪个类加载器加载。可以发现**自定义类的加载器都是同一个。**

# 静态代理

回顾：一个老板的接口Boss，有与人见面和消费的功能。

以煤老板为例，实现Boss的接口。老板都有秘书，定义一个类CoalBossProxy，专门为煤老板做代理的代理秘书。**见到了秘书相当于见到了老板（在秘书类实例化时将老板属性也实例化）**，在代理秘书类里定义一个老板，秘书专门为煤老板服务。创建代理秘书的实例时创建老板。代理秘书都有什么功能？想见老板必须通过秘书，像买房子找中介一样。想让老板干什么都要通过秘书，**想让老板消费、见面都要通过秘书**，类似于秘书具备了见面和消费的功能，所以秘书也要实现Boss接口和接口中的方法。但只找秘书不好使，最终见面、消费还是让老板来进行。就像买房子，我们知道中介有房子，但最终卖房子的还是卖家。一些不需要老板完成的事就让秘书来完成，比如见面前需要完成的一些操作和见面结束后的一些操作。

```java
package com.itdianbo.proxy;

/**
 * Created with IntelliJ IDEA.
 *
 * @author : wu_qing
 * @version : 1.0
 * @Project : TestProJect
 * @Package : com.itdianbo.proxy
 * @ClassName : .java
 * @createTime : 2024/2/23 18:45
 * @Email : 1553232108@qq.com
 * @Description :
 */
public class CoalBossProxy implements Boss {

    private CoalBoss cb;

    public CoalBossProxy() {
        cb = new CoalBoss(); // 见到了秘书相当于见到了老板
    }

    @Override
    public void meet() {
        System.out.println("--------代理开始--------");

        cb.meet();
        System.out.println("--------代理结束--------");
    }

    @Override
    public void consume() {
        System.out.println("--------代理开始--------");
        cb.consume();
        System.out.println("--------代理结束--------");
    }
}

```

接下来具体怎么使用？想找煤老板必须找秘书，然后让老板见面、消费。

```java
public class DynamicProxyHandler {

    public static void main(String[] args) {
        CoalBossProxy coalBossProxy = new CoalBossProxy();

        coalBossProxy.meet();
        coalBossProxy.consume();
    }
}
```

![image-20240223185904863](.\images\image-20240223185904863.png)

**此时注意秘书在过程中做了很多工作，也有很多功能。**

如果现在老板变多了，比如多了一个钢铁老板，钢铁老板照样也具备消费和见面的功能。煤老板有秘书，那钢铁老板也有秘书SteelBossProxy，专门为钢铁老板做代理。见到秘书就相当于见到了老板，这个秘书也相当于具备了见面和消费的功能。同样的，核心的见面和消费都是老板来进行的。

此时发现两个老板的秘书干的事都是一样的，都是见面和消费。其他功能几乎都是一模一样的。

```java
public class DynamicProxyHandler {

    public static void main(String[] args) {
        CoalBossProxy coalBossProxy = new CoalBossProxy();

        coalBossProxy.meet();
        coalBossProxy.consume();

        SteelBossProxy steelBossProxy = new SteelBossProxy();

        steelBossProxy.meet();
        steelBossProxy.consume();
    }
}
```

![image-20240223190627692](.\images\image-20240223190627692.png)

问题是见煤老板要找煤老板秘书，见钢铁老板要找钢铁老板秘书。即**秘书和老板紧密的耦合在一块**了，煤老板秘书只为煤老板服务，钢铁老板秘书只为钢铁老板服务。

比如现在有3个老板，每个老板都有自己的秘书，我们称为**代理对象**。现在就有3个老板和3个秘书，意味着现在如果我们想找煤老板就得找煤老板的代理对象，找钢铁老板就得找钢铁老板的代理对象，找另一个老板就得找另一个的代理对象。对“我”来说非常麻烦。

![image-20240223201552569](.\images\image-20240223201552569.png)

# 动态代理

不过我们知道买房、卖房、租房只需要找一家中介就都可以进行，所以我们也想只有一个代理，不管见哪个老板都通过这一个代理来实现。比如要找1号老板，那此时就是为1号老板的代理，要找2号老板，就动态的变成为2号老板的代理，要找3号就变成3号老板的代理。只需要告诉代理对象想要什么即可。

![image-20240223201932491](.\images\image-20240223201932491.png)

## 通过反射完成动态代理

需要实现接口`InvocationHandler`来创建一个动态代理类，首先要有被代理的目标对象`target`，比如煤老板、钢铁老板。但此时不能写死，需要是动态的，所以是Object类型。接下来要生成代理对象，因为要动态指定被代理的对象，所以自己搞一个方法。首先要指定动态对象为谁做代理，接下来生成对象，直接利用反射API写好的方法`Proxy.instance(...);`，利用这个方法就能动态的生成代理类对象。

参数分析

1. 第一个参数为类加载器，动态生成的代理类是由哪个类加载器加载的，一般和目标对象一致。老板用哪个就用哪个就完事儿。
2. 第二个参数为动态实现的代理类需要实现的接口，跟目标对象实现的接口一样，实现哪些接口就相当于有哪些方法，实现接口的目的是为了接口中的方法，这样底层生成的代理类也可以用这几个方法。
3. 实现了动态代理接口InvocationHandler的实例，只要是InvocationHandler的实例都可以，主要是为了重写的invoke()方法，**通过重写的invoke方法实现代理功能**。

invoke参数分析

1. proxy：代理类对象，就是Proxy.newProxyInstance()方法生成的对象
2. method：代理对象需要执行的方法
3. args：执行方法时的参数列表

method.invoke()时问题来了，代理类执行方法，最终执行谁的meet/consume，代理类虽然也有meet也有consume，但具体的执行还是老板来执行。在方法执行前后干点事情，之前两个秘书干的事都是一样的，现在只需要写一次即可。此时的invoke方法就形成了面向切面编程AOP。上下固定，中间不断变化。

```java
package com.itdianbo.java;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 动态代理：需要实现接口InvocationHandler
 */
public class DynamicProxyHandler implements InvocationHandler {

    // 目标对象，要代理的对象，也就是老板
    private Object target;

    // 动态生成代理对象，指定为谁做代理
    public Object newProxyInstance(Object target) {
        this.target = target;

        // 利用反射API 生成代理对象，也就是秘书
        /**
         * 参数1：让哪个类加载器加载动态生成的代理类，目标对象用哪个就用哪个
         * 参数2：动态实现的代理类需要实现哪个接口，跟目标对象实现的接口一样，
         *      就相当于有哪些方法，实现接口的目的是为了接口的方法，这样底层生成的代理类也可以用这几个方法
         * 参数3：实现了动态代理接口InvocationHandler的实例，目前这个类就是，只要是InvocationHandler的实例都可以，主要是为了重写的方法
         */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }


    /**
     * 通过这个方法来完成代理
     * @param proxy 代理类对象，就是Proxy.newProxyInstance()方法生成的对象
     * @param method 代理对象需要执行的方法 meet/consume
     * @param args 执行方法时的参数列表
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("--------代理开始--------");
        Object obj = method.invoke(target, args);// 执行目标对象的方法
        System.out.println("--------代理开始--------");
        
        return obj;
    }
}

```

此时就不需要这么多秘书了，只需要一个动态秘书

```java
public class DynamicProxyHandlerMain {
    public static void main(String[] args) {
        /*CoalBossProxy coalBossProxy = new CoalBossProxy();

        coalBossProxy.meet();
        coalBossProxy.consume();

        SteelBossProxy steelBossProxy = new SteelBossProxy();

        steelBossProxy.meet();
        steelBossProxy.consume();*/

        DynamicProxyHandler dynamicProxyHandler = new DynamicProxyHandler();
        // 想见煤老板
        Boss coalBoss = (Boss) dynamicProxyHandler.newProxyInstance(new CoalBoss());
        coalBoss.meet();
        coalBoss.consume();

        // 想见钢铁老板
        Boss steelBoss = (Boss) dynamicProxyHandler.newProxyInstance(new SteelBoss());
        steelBoss.meet();
        steelBoss.consume();
    }
}

```

此时运行也是可以的，这样我们就用一个动态秘书实现了所有秘书的功能。

![image-20240223210249576](.\images\image-20240223210249576.png)

# String、StringBuffer、StringBuilder

- String：不可变的字符序列，底层字符数组用final修饰了，不管怎么改变都会产生新的序列，创建在元空间中。节省空间，经常改浪费时间。
- StringBuffer和StringBuilder：可变的字符序列，底层字符数组没用final修饰，创建在堆中。浪费空间，经常改节省时间。默认长度为16，可通过有参构造调整初始容量。一旦存满16，会复制到一个新数组中，新数组长度为原来数组长度\*2 + 2。
- StringBuffer和StringBuilder的区别：Buffer是线程安全的，因此效率低。Builder是不安全的，因此效率高。此外二者具有兼容的API，即使用方式一模一样。



# 多线程安全问题

多个线程同时访问共享数据时，产生了无序、重复、超额等多线程问题。

以售票程序为例：先判断是否有余票，有则计算余票，打印余票数量

若有3个窗口，1号窗口在计算余票之后（设余票为4），打印之前被剥夺了CPU使用权，2号窗口获得了使用权，计算余票之后试图打印余票为3，此时2号被剥夺执行权。假设3号获得执行权，计算余票（为2），3号窗口恰好都能执行完，就会`打印余票为2`。3个窗口继续抢占资源，1号抢到后会继续刚才的进度继续向下执行，``打印余票为4`。若2号抢到后就会`打印余票为3`。这样就**产生了无序问题**。

**原因在于抢占式策略不可控**

如果在判断有无余票后就被剥夺使用权，**会导致超额问题**。现在余票为2，1号窗口在判断有无余票后背剥夺使用权，2号也在判断后被剥夺使用权，3号可以顺利完成后边两步操作，此时`打印余票为1`，若1号抢到使用权并完成执行，此时`打印余票为0`，若2号抢到控制权并完成执行，**此时`打印余票为-1`**

## 解决多线程安全问题

把判断是否有余票，计算余票，打印余票数量，需要访问的共享数据包装成一个整体，确保一次只有一个线程执行流访问共享数据。只要执行没完成别的线程就禁止访问。

抢到锁进入执行后，上锁，然后开始执行。只要没完成执行，其他线程就不能开始执行。执行结束后释放锁，线程再开始抢锁。**并行变成了串行，把访问共享数据的操作变成串行以保证线程安全。**
没有共享数据的部分保持多线程。

1. 同步代码块
    ```java
    synchronized(同步监视器) {
        多个线程要访问的共享数据
    }
    ```
    同步监视器：就是锁，可以使用任意类型对象充当。**必须保证多个线程持有同一把锁。（同一个对象）**

2. 同步方法
    在方法声明处加`synchronized`即可，用方法包装共享数据
    ```java
    public synchronized void show() {
        多个线程要访问的共享数据
    }
    ```
    非静态同步方法的隐藏锁是this，静态同步方法的锁为对应类的Class实例
3. 同步锁 lock
    创建类ReentrantLock的实例，利用方法lock()上锁和unlock()释放锁
    **注意：必须通过unlock()手动释放锁，严谨起见可以使用`try...finally`**
    ```java
    l.lock(); // 上锁
    try {
        多个线程要访问的共享数据
    }
    finally {
        l.unlock(); // 释放锁
    }
    ```
    **这个锁实际上是悲观锁**

# 死锁问题

先抢锁1，再抢锁2
先抢锁2，再抢锁1
如果两个线程分别抢了锁1和锁2，此时两个线程分别等待锁2和锁1，两个线程互相等待就产生了死锁
解决：专门的算法、原则；尽量减少同步资源的定义
1. 设置超时时间，超过时间限制后放弃对资源的请求和自己持有的锁
2. 加锁顺序，按照一定顺序获得锁

# 接口与抽象类的区别
抽象类：父类只能知道子类应该有怎样的方法，但不能知道子类如何实现该方法
如计算面积，所有图形都应该有计算面积的功能，但不同图形计算方法不同
Java允许父类中只提供方法的声明不提供具体的实现，具体实现交给子类完成，这样的方法称为抽象方法，拥有抽象方法的类称为抽象类。
接口解决了单继承的局限性。
类是 is a 的关系，接口是 has a 的关系
JDK1.8对接口的改动：允许接口声明默认方法和静态方法（为了支持Lambda表达式）
1. 一个类只能继承另一个类，但可以实现多个接口
2. 抽象类是其他类的"同类"，接口是描述一个对象可以做什么
3. 抽象类的 抽象方法 必须在子类中实现，接口的 所有方法 必须在实现类中实现
4. 抽象类可以有 构造方法 和 非抽象方法

# OSI七层架构

物数网运会表应



# TCP/IP四层架构

网网运应

## TCP三次握手

1. 客户端发送请求建立连接，第一次握手，SYN，序号=1145
2. 服务端发送确认应答并请求建立连接，第二次握手，SYN+ACK，序号=1919，确认号=客户端序号1145+1
3. 客户端针对服务端的确认应答的确认应答，第三次握手，ACK，序号=服务端确认号1145+1，确认号=服务端序号1919+1

![image-20240308123837639](.\images\image-20240308123837639.png)

能否使用两次握手？不能

若第一次握手的连接请求在网络中滞留，客户端重新发送了一个建立连接请求，此时正常到达服务器，服务器发送确认应答后进入连接建立状态，客户端收到确认后也进入连接建立状态。在结束数据传输并通过四次挥手释放连接后，服务器收到了滞留的连接请求，会认为是客户端想要再次建立连接。发送确认应答后进入连接建立状态，但客户端处于关闭状态，故不会理会这个确认应答。但服务器已经进入连接建立状态，并等待客户端发来数据，将会浪费服务器主机的很多资源。

![image-20240308124349576](.\images\image-20240308124349576.png)





## TCP四次挥手

客户端和服务端都能主动发起关闭请求
1. 客户端发送请求断开连接，第一次挥手，FIN+ACK，序号，确认号
2. 服务端发送确认应答，第二次挥手，ACK，序号=客户端确认号，确认号=客户端序号+1
3. 服务端请求断开连接，第三次挥手，FIN+ACK，序号和确认号不改变
4. 客户端发送确认应答，第四次挥手，ACK，序号=服务端确认号，确认号=服务端序号+1

![image-20240308124527459](.\images\image-20240308124527459.png)

如果没有时间等待状态会怎么样？

如果在收到服务端请求断开连接后，发送确认应答并进入关闭状态，然而确认应答丢失了，这必然会造成服务器的超时重传，并仍处于最后确认状态，重传的请求断开连接到达客户端，但客户端已经关闭因此不会理会，会造成服务器反复重传请求断开连接，无法进入关闭状态。

因此时间等待状态可以确保服务器可以收到最后一个确认应答而进入关闭状态。另外，等待2MSL时长可以使本次连接持续时间内产生的所有报文段都从网络中消失。

# 网络编程

Java提供的网络类库，可以实现无痛网络连接，底层细节隐藏在Java的本机安装中，由JVM控制，并且Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。









# 数据库

# 如何定位慢查询

一般慢查询出现的情况：聚合查询、多表查询、表数据量过大查询、深度分页查询

表象：页面加载慢、接口测试时响应时间长

- 方案一：使用开源工具
  - 调试工具Arthas，通过命令监控已经上线的项目，可以跟踪执行慢的方法，查看执行时间最终定位问题。
  - 运维监控工具skywalking，在监控中有一些指标数据可以实时查看接口情况。可以快速定位哪个接口比较慢。还可以跟踪接口在各个阶段的耗时。
- 方案二：MySQL自带慢日志
  - 默认没有开启这项功能，需要在配置文件中手动开启。`slow_query_log= 1 `
  - 慢日志记录了所有执行时间超过指定参数（`long_query_time`单位秒，默认10秒，一般设2秒）的SQL语句日志。

回答问题：

1. 介绍问题场景
2. 采用了运维工具，监测接口，确定是SQL的问题
3. 如果没用过工具，可以说开启了慢日志查询，设置时间为2秒，一旦SQL超过2秒就记录到日志中。（一般只在调试时开启，生产阶段不会使用，因为会损耗性能）

# 如何优化慢查询

如果出现的是：聚合查询、多表查询，想办法优化SQL语句就行了。比如聚合查询可以尝试新增临时表，多表查询可以尝试优化SQL语句结构。

如果是数据量过大查询，可以添加索引。但有时已经有了索引，SQL依然很慢该怎么办？

分析SQL执行执行计划（三种情况都可以通过分析来找到执行慢的原因）

深度分页查询，此时略

可以使用`EXPLAIN或DESC`获取MySQL执行`select`语句的信息，这样展示的内容不是表中的数据而是SQL的执行情况。

`explain select xxx from xxx where conditions;`

比较重要的字段：

1. `possible_keys`：SQL执行时可能使用到的索引
2. `key`：当前SQL实际命中的索引
3. `key_len`：索引占用的大小，通过`key key_len`来确定SQL是否命中了索引
4. `extra`：额外优化建议，`using where;using index`代表查找使用了索引，数据在索引中都能找到，不需要回表查询。`using index condition`代表使用了索引，**但需要回表查询数据**。
5. `type`：SQL的连接类型，**性能由好到差为**`NULL system const eq_ref ref range index all`
   1. NULL：SQL执行时没有用到表
   2. system：查询的是MySQL内置的表
   3. const：根据主键查询
   4. eq_ref：查询条件是根据主键索引查询或唯一索引查询，只能返回一条数据
   5. ref：根据其他索引查询，可能返回多条数据
   6. range：范围查询
   7. index：索引树扫描/全索引扫描
   8. all：全盘扫描

回答问题：

1. 通过MySQL自带分析工具explain字段
   1. 通过key和key_len检查是否命中了索引（还可以判断索引是否失效）
   2. 通过type查看SQL是否有优化的空间，是否存在全索引扫描或全盘扫描
   3. 通过extra判断是否出现了回表情况，如果出现，可以尝试添加索引或修改返回字段来修复

# 索引概念和索引的底层结构

索引是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护特定查找算法的数据结构（B+树），数据结构以某种方式引用数据，这样就可以在数据结构上实现高级查找算法。

B+树：多叉树+叶节点双向链表

**B+树非叶结点存储指针，只有叶节点存储数据**。

根节点关键字个数为1~n，其他节点为$\lfloor \frac{m}{2} \rfloor$到m个关键字

非叶且非根节点至少有两棵子树，其他每个分支节点至少有$\lceil \frac{m}{2} \rceil$棵子树

**节点子树个数与关键字个数相等，这是与B树的明显不同**

B+树读写代价更低（路径上的节点不记录数据），查询效率更稳定（都要查询到叶节点），便于扫库和区间查询（扫描叶节点的双向链表）

回答问题：

1. 索引是帮助MySQL高效获取数据的数据结构，是有序的
2. 提高数据检索效率，降低磁盘读写成本
3. 通过索引对数据进行排序时，降低排序成本，降低CPU的消耗，因为建索引的时候就需要排序

索引底层结构：

1. MySQLInnoDB引擎采用B+树结构存取索引
2. 阶数更多，路径更短，是矮胖树
3. 磁盘读写代价B+树更低，非叶节点不存储数据
4. B+树便于扫库和区间查询，因为叶节点是双向链表

# 什么是聚簇索引和非聚簇索引/什么是回表

聚簇索引也叫聚集索引，非聚簇索引也叫二级索引

- 聚集索引：将数据存储与索引放到一块，索引结构的**叶子节点保存了整行数据**，**必须有且只有一个**。
  - 不是所有字段都可以当做聚集索引，有一些选取规则：
    1. 如果存在主键，主键索引就是聚集索引
    2. 如果不存在主键，第一个唯一索引就是聚集索引
    3. 如果都没有，则innoDB引擎会自动生成一个rowid作为隐藏的聚集索引
- 二级索引：将数据域索引分开存储，索引结构的**叶节点保存的是对应的主键**，可以存在多个。
  - 给一些属性添加了索引，就是二级索引

![image-20240224104406253](.\images\image-20240224104406253.png)

回表查询：现在有一条SQL：`select * from user where name = 'Arm'`，首先这条SQL会走二级索引，查找到对应叶节点。此时注意SQL里写的是`*`，而二级索引中存储的只有主键id，不能拿到所有数据。所以会再将id拿到聚集索引中找，在聚集索引中最终查询到整行的数据。



回答问题：

1. 聚簇索引就是数据和索引存放到一块，B+树的叶节点保存了整行的数据，有且只有一个
2. 非聚簇索引就是数据和索引不放到一块，叶节点只保存每行数据的主键，可以有多个非聚簇索引
3. 回表查询就是通过二级索引找到主键值，再通过主键值在聚集索引中查找整行数据



# 什么是覆盖索引

查询使用了索引，并且需要返回的字段在该索引中已经可以全部找到。

举例，id为主键，name为普通索引：

- `select * from user where id = 1;`，这是一个覆盖索引，因为是根据`id`进行查询会走聚簇索引，而聚簇索引中会存放整行的数据，所以`select *`**需要返回的字段在该索引中已经可以全部找到**。
- `select id, name from user where name = 'arm';`，这也是覆盖索引，因为根据的是`name`查询会走二级索引，而二级索引中只会存放主键id，自己就是name，所以可以在索引中找到需要返回的字段。
- `select id, name, gender from user where name = 'arm'`，这个不是覆盖索引，因为`gender`字段仅通过`name`的索引查找并不能直接获取到，还需要回到聚簇索引中查找。

回答问题：

1. 覆盖索引是指查询使用了索引并且返回的字段值必须在索引中全部能找到
2. 使用主键查询，走聚集索引，通过一次查询就可以直接返回数据，性能比较高。
3. 如果返回的列没有创建索引，可能会触发回表查询，所以平时要尽量避免使用`select *`

# MySQL超大分页怎么处理

数据量比较大时，如果通过limit进行分页查询，查询的数据越靠后，分页查询效率越低。

如`select * from user limit 0, 10;`和`select * from user limit 9000000, 10;`，同样是查询十条数据，第二条SQL的效率会非常低。在`limit 9000000, 10`时，MySQL需要排序前9000010条记录，返回9000000~9000010的记录，其他记录丢弃，查询代价非常大。

通过覆盖索引+子查询来优化：`select * from user user, (select id from user order by id limit 9000000, 10) a where user.id = a.id; `，注意子查询`select id from user order by id limit 9000000, 10`在根据id排序和返回id时会走覆盖索引，性能比较高，再和之前的表做关联，性能就会有所提升。

回答问题：

1. 数据量比较大时，如果通过limit进行分页查询，查询的数据越靠后，分页查询效率越低。
2. 通过覆盖索引+子查询，子查询中进行分页查询获取id，这个是比较快的，再和原来的表进行关联查询，这样效率就可以提升很多。



# 索引创建原则

1. 数据量大，查询频繁的表（单表10w+数据）
2. 常作为where、order by、group by条件中使用的字段
3. 选择区分度高的列作为索引，尽量建立唯一索引（字段值重复性不高）
4. 字符串类型的字段且长度较长，可以针对字段特点创建前缀索引
5. 尽量使用联合索引，减少单列索引，联合索引很多时候可以覆盖索引，避免回表提高效率
6. 控制索引数量，索引越多维护代价越大，会影响增删改效率
7. 如果索引列不能存储NULL值，要在建表时使用NOT NULL来约束。优化器知道每列是否包含NULL时，可以更好的确定哪个索引能最有效的用于查询

回答问题：

1. 数据量大
2. 常作为条件的
3. 联合索引
4. 索引数量

# 索引失效

情况很多，可以根据实际情况来回答。通过explain字段来判断。

1. 违反最左前缀法则，如果索引了多列，要遵守最左前缀法则。指查询从索引的最左前列开始且不跳过索引中的列。如有联合索引`name status address`，在查询时使用条件`name = xx`、`name = xx and status = xx`、`name = xx and status = xx and address = xx`，都可以使用到联合索引。但如果**跳过开头在内的连续列进行查询，索引就可能失效**，如直接使用`address = xx`。在explain返回的信息中表现为`key key_len`都为`NULL`。如果**跳过的是中间列，则只有跳过列之前的索引有效**，如`name = xx and address = xx`，这样只有`name`会生效。
2. 范围查询条件后的列不能使用索引，如`name = xx and status > xx and address = xx`，此时`address`的索引会失效，只有前两个有效。
3. 索引列上进行运算操作，索引将失效，查询条件中对索引字段进行了一些操作如`substring`，在explain中会发现索引失效。
4. 字符串不加单引号，造成索引失效，如`name = 'xx' and status = 'xx'`和`name = 'xx' and status = xx`，第二种可能会导致status的索引失效。MySQL的查询优化器会自动进行类型转换造成索引失效。
5. 以%开头的like模糊查询，**可能**导致索引失效。如果只是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。















# 单例bean是安全的吗

首先要明确，默认bean对象是单例的，可以通过@Scope来修改bean对象的数量。

结论：不是线程安全的

一般在Spring的bean中都是无状态的对象，也就是不可修改的对象，没有线程安全问题，如果bean中定义了可修改的成员变量，就需要考虑线程安全问题，可以使用prototype或者加锁来解决。



# AOP

AOP，面向切面编程。用来将与业务无关，但多个对象都需要使用的公共逻辑封装成一个可重用的模块，减少重复的代码，降低了模块的耦合度。

常见使用场景：

1. 记录操作日志
2. 缓存处理
3. Spring内置的事务处理

以记录操作日志为例

首先封装一个Aspect切面类，需要`@Component @Aspect`注解。在类中定义方法来实现原始方法运行前后的逻辑，方法需要**指定通知类型和切入点**，切入点通过切入点表达式指定。通过**API直接获取方法的所有内容**（方法名、内容、注解等等），最后将获取的信息记录到数据库中，并放行原始方法，返回原始方法的返回值。